---
sidebar_label: "Multichain Validation"
sidebar_position: 3
description: "Overview of Multichain Validation Module with ECDSA Ownership"
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Multichain Validation Module

This module acts as an extention of the [ECDSA Module](/Modules/ecdsa). The added benefit of this module is you now have the ability to sign once and authorize any number of userOps across multiple blockchain networks.

### What is the Multichain Validation Module? ü§î

This module allows **Externally Owned Accounts (EOAs)** to authorize and sign user operations (UserOps) for Biconomy Smart Accounts on Multiple chains with single ECDSA signature. 

**Benefits**
- significantly improves UX for deploying and setting up Smart Accounts on several chains 
- significantly reduces user friction for multichain operations.

:::tip
You can use also this module as the **default module** just like ECDSA Validation Module as it has all it's capabilities for sending ops on particular chain.
:::

#### Key Functions üîê

- **ECDSA Signature Scheme**: Utilizes the ECDSA secp256r1 curve for secure signing.
- **Flexible Signer Authentication**: Supports various signer solutions like Privy, Fireblocks, Arcana Auth, Capsule, Lit protocol, Turnkey, Web3Auth, Particle, Magic, Portal etc
- **EIP-1271 Compliance**: Allowing Smart Accounts to sign Ethereum messages for logging into dApps.
- **Sign once, Execute on multiple chains**

#### Use Cases üåü

Enables use cases which require several actions to be authorized for several chains with just one signature required from user.

1. **Multichain intent for example exit all my native tokens for usdc
2. **Allows a dApp to require just one signature from their user to configure & deploy smart accounts on multiple chains and delegate certain actions with permission via session keys on all those chains
3. **Cross chain state sync actions e.g transfer ownership of SA, change ens, similar actions on protocol that is deployed on multiple chains
4. **Onboard user on x chains by deploying their smart account + some action like register in raffle 

### How does it work? ü§î

1. We take all the userOps which we need to sign.
2. We get userOpHash from those userOps.
3. Every userOpHash is now a leaf of a Merkle Tree.
4. Instead of signing several userOpHash separately, user signs one Merkle Root.
5. Now we can reliably prove on-chain that a userOp is a leaf of a tree whose root has been signed by an authorized user.

Now user can authorize any amount of userOps with just one signature over the Merkle Root of those userOps


## Smart Contract Deep Dive üõ†Ô∏è

You can send a multi-chain signature to send different userops on different chains and be validated by this module. if plain ecdsa signature(65 bytes) is sent then the module assumes it‚Äôs form as standard ECDSA validation module

#### User Operation Validation (`validateUserOp`) üõ°Ô∏è

```solidity

function validateUserOp(
        UserOperation calldata userOp,
        bytes32 userOpHash
    ) external view virtual override returns (uint256) {

       // userOp.signature contains both the signature and the validation module's address

        (bytes memory moduleSignature, ) = abi.decode(
            userOp.signature,
            (bytes, address)
        );


       // Validates the operation against the intended owner's signature, ensuring it's authorized. 

 
        if (moduleSignature.length == 65) {
            // it's not a multichain signature
            return
                _verifySignature(
                    userOpHash,
                    moduleSignature,
                    address(uint160(sender))
                )
                    ? VALIDATION_SUCCESS
                    : SIG_VALIDATION_FAILED;
        }


        // otherwise it is a multichain signature
        (
            uint48 validUntil,
            uint48 validAfter,
            bytes32 merkleTreeRoot,
            bytes32[] memory merkleProof,
            bytes memory multichainSignature
        ) = abi.decode(
                moduleSignature,
                (uint48, uint48, bytes32, bytes32[], bytes)
            );

        // make a leaf out of userOpHash, validUntil and validAfter
        bytes32 leaf = keccak256(
            abi.encodePacked(validUntil, validAfter, userOpHash)
        );

        if (!MerkleProof.verify(merkleProof, merkleTreeRoot, leaf)) {
            revert("Invalid UserOp");
        }

        return
            _verifySignature(
                merkleTreeRoot,
                multichainSignature,
                address(uint160(sender))
            )
                ? _packValidationData(
                    false, //sigVerificationFailed = false
                    validUntil == 0 ? type(uint48).max : validUntil,
                    validAfter
                )
                : SIG_VALIDATION_FAILED;
    }

```

All the other methods are inherited from [ECDSAOwnershipRegistryModule](https://github.com/bcnmy/scw-contracts/blob/main/contracts/smart-account/modules/EcdsaOwnershipRegistryModule.sol)


#### References

1.**[Source code](https://github.com/bcnmy/scw-contracts/blob/develop/contracts/smart-account/modules/MultichainECDSAValidator.sol)**

2.**[Merkle Trees](https://www.simplilearn.com/tutorials/blockchain-tutorial/merkle-tree-in-blockchain)**


## How to Guide - Biconomy SDK üìò 

Integrate the Multichain Validation Module into Biconomy Smart Accounts using the SDK.



### Setup and Installation üõ†Ô∏è

<Tabs>
<TabItem value="js" label="npm">

```bash

npm install @biconomy/modules ethers

```

</TabItem>
<TabItem value="py" label="yarn">

```bash

yarn add @biconomy/modules ethers

```

</TabItem>
<TabItem value="java" label="pnpm">

```bash

pnpm add @biconomy/modules ethers

```

</TabItem>
</Tabs>

### Creating a Signer üóùÔ∏è

```javascript
import { ethers } from "ethers";

const provider = new ethers.providers.JsonRpcProvider("[RPC_Endpoint]");
const signer = new ethers.Wallet("[Private_Key]", provider);
```

### Integration - Importing and Initializing Multichain Validation Module üåü

```typescript
import {
  MultiChainValidationModule,
  DEFAULT_MULTICHAIN_MODULE,
} from "@biconomy/modules";

// Notice this is chain agnostic so same instance can be used on instances of Smart account API on different chains
const multiChainModule = await MultiChainValidationModule.create({
  signer: signer,
  moduleAddress: DEFAULT_MULTICHAIN_MODULE,
});
```

Once initialized it can be passed to the smart account [create method](/Account/methods/create) to create instances of the smart account.
Check [Paymaster integration](/Paymaster/integration) and [Bundler integration](/Bundler/integration) sections to create instances of them.

Here is how you can set up Smart Account instances accross multiple chains:


```ts

import { BiconomySmartAccountV2 } from "@biconomy/account";

let baseAccount = await BiconomySmartAccountV2.create({
    chainId: ChainId.BASE_GOERLI_TESTNET,
    paymaster: //basePaymaster,
    bundler: //baseBundler,
    rpcUrl: // Base Goerli Rpc
    entryPointAddress: DEFAULT_ENTRYPOINT_ADDRESS,
    defaultValidationModule: multiChainModule, // this can also be ecdsaModule instance (MUST if SA is already created with ecdsa as default module)
    activeValidationModule: multiChainModule
  });

let polygonAccount = await BiconomySmartAccountV2.create({
    chainId: ChainId.POLYGON_MUMBAI,
    paymaster: //polygonPaymaster,
    bundler: //polygonBundler,
    rpcUrl: // Polygon Mumbai Rpc
    entryPointAddress: DEFAULT_ENTRYPOINT_ADDRESS,
    defaultValidationModule: multiChainModule, // this can also be ecdsaModule instance
    activeValidationModule: multiChainModule
  });

```

### Integration - Signing and Sending Multichain useropsüåü

```typescript


  // This could be swap action, mint nft, transfer ownership, enable different module as such (check use cases above) which you intend to do on multiple chains
  // You can also batch with providing just array of transactions
  // If the smart account is not deployed it would be deployed as part of this transaction. No additional action needed in below payload 
  const transaction = {
    to: <DESTINATION_CONTRACT_ADDRESS>, 
    data: <DESTINATION_CONTRACT_METHOD_ENCODED_DATA>,
  };

  // Build partial userOp for chain1
  let partialUserOp1 = await baseAccount.buildUserOp([transaction], { 
    // Assuming Sponsorship Paymaster is to be used otherwise leave as it's optional
    paymasterServiceData: {
    mode: PaymasterMode.SPONSORED,
  }});

  // Build partial userOp for chain2
  let partialUserOp2 = await polygonAccount.buildUserOp([transaction], { 
    // Assuming Sponsorship Paymaster is to be used otherwise leave as it's optional
    paymasterServiceData: {
    mode: PaymasterMode.SPONSORED,
  }});

  // Use multichain module to sign once for all ops
  const returnedOps = await multiChainModule.signUserOps([{userOp: partialUserOp1, chainId: ChainId.BASE_GOERLI_TESTNET}, {userOp: partialUserOp2, chainId: ChainId.POLYGON_MUMBAI}]);


  const userOpResponse1 = await baseAccount.sendSignedUserOp(returnedOps[0] as any);
  // You can also just wait for transaction hash by waitForTxHash()
  const transactionDetails1 = await userOpResponse1.wait();

  const userOpResponse2 = await polygonAccount.sendSignedUserOp(returnedOps[1] as any);
  const transactionDetails2 = await userOpResponse2.wait();
```

:::info
If Smart Account is not deployed yet then it makes sense to pass multiChainModule as defaultValidationModule. That was it would get enabled by default and has all Ecdsa Module (popular go-to module) capabilities. 
:::




### Conclusion

It reduces user friction for dApps which for example want to quickly and seamlessly deploy and configure Smart Accounts on several chains or issue session keys with the permissions that vary from chain to chain.

"Mutlichain module allows us to use sessions keys and setup sessions on multiple chains with single wallet signature." - [Rage Trade](https://www.rage.trade/)